#include <cstdlib>
#include <iostream>
#include <map>
#include <string>

#include "TChain.h"
#include "TFile.h"
#include "TTree.h"
#include "TString.h"
#include "TObjString.h"
#include "TSystem.h"
#include "TROOT.h"

//#if not defined(__CINT__) || defined(__MAKECINT__)
//needs to be included when makecint runs (ACLIC)
#include "TMVA/Factory.h"
#include "TMVA/Tools.h"
//#endif


void TMVAClassification()
{
   TMVA::Tools::Instance();


  
   std::cout << "==> Start TMVAClassification" << std::endl;
   std::cout << "-------------------- open input file ---------------- " << std::endl;
   TString fname = "../tau_data/training.root";
   TFile *input = TFile::Open( fname );

   std::cout << "-------------------- get tree ---------------- " << std::endl;
   TTree *tree     = (TTree*)input->Get("data");
   
   TString outfileName( "TMVA.root" );

   std::cout << "-------------------- open output file ---------------- " << std::endl;
   TFile* outputFile = TFile::Open( outfileName, "RECREATE" );

   std::cout << "-------------------- prepare factory ---------------- " << std::endl;
   TMVA::Factory *factory = new TMVA::Factory( "TMVAClassification", outputFile,
                                               "AnalysisType=Classification" );
   std::cout << "-------------------- add variables ---------------- " << std::endl;
   factory->AddVariable("LifeTime", 'F');
   factory->AddVariable("FlightDistance", 'F');
   factory->AddVariable("FlightDistanceError", 'F');
   factory->AddVariable("pt", 'F');
   factory->AddVariable("IP", 'F');
   factory->AddVariable("dira", 'F');
   factory->AddVariable("DOCAone", 'F');
   factory->AddVariable("DOCAtwo", 'F');
   factory->AddVariable("DOCAthree", 'F');
   factory->AddVariable("IP_p0p2", 'F');
   factory->AddVariable("IP_p1p2", 'F');
   factory->AddVariable("isolationa", 'F');
   factory->AddVariable("isolationb", 'F');
   factory->AddVariable("isolationc", 'F');
   factory->AddVariable("isolationd", 'F');
   factory->AddVariable("isolatione", 'F');
   factory->AddVariable("isolationf", 'F');
   factory->AddVariable("iso", 'F');
   factory->AddVariable("CDF1", 'F');
   factory->AddVariable("CDF2", 'F');
   factory->AddVariable("CDF3", 'F');
   factory->AddVariable("ISO_SumBDT", 'F');
   factory->AddVariable("p0_IsoBDT", 'F');
   factory->AddVariable("p1_IsoBDT", 'F');
   factory->AddVariable("p2_IsoBDT", 'F');
   factory->AddVariable("p0_track_Chi2Dof", 'F');
   factory->AddVariable("p1_track_Chi2Dof", 'F');
   factory->AddVariable("p2_track_Chi2Dof", 'F');
   factory->AddVariable("p0_pt", 'F');
   factory->AddVariable("p0_p", 'F');
   factory->AddVariable("p0_eta", 'F');
   factory->AddVariable("p0_IP", 'F');
   factory->AddVariable("p0_IPSig", 'F');
   factory->AddVariable("p1_pt", 'F');
   factory->AddVariable("p1_p", 'F');
   factory->AddVariable("p1_eta", 'F');
   factory->AddVariable("p1_IP", 'F');
   factory->AddVariable("p1_IPSig", 'F');
   factory->AddVariable("p2_pt", 'F');
   factory->AddVariable("p2_p", 'F');
   factory->AddVariable("p2_eta", 'F');
   factory->AddVariable("p2_IP", 'F');
   factory->AddVariable("p2_IPSig", 'F');
//   factory->AddVariable("SPDhits", 'F');
   
   std::cout << "-------------------- add trees ---------------- " << std::endl;
   factory->AddTree(tree, "Signal", 1.0, TCut("signal==1"), "TrainingTesting");
   factory->AddTree(tree, "Background", 1.0, TCut("signal==0"), "TrainingTesting");

   TCut mycuts = ""; // for example: TCut mycuts = "abs(var1)<0.5 && abs(var2-0.5)<1";
   TCut mycutb = ""; // for example: TCut mycutb = "abs(var1)<0.5";
   
   std::cout << "-------------------- prepare ---------------- " << std::endl;
   factory->PrepareTrainingAndTestTree( mycuts, mycutb,
                                        "nTrain_Signal=5000:nTrain_Background=5000:nTest_Signal=5000:nTest_Background=5000:SplitMode=Random:NormMode=NumEvents:!V" );
   
   // gradient boosting training
   factory->BookMethod(TMVA::Types::kBDT, "GBDT",
                       "NTrees=40:BoostType=Grad:Shrinkage=0.01:MaxDepth=7:UseNvars=6:nCuts=20:MinNodeSize=10");

   factory->BookMethod( TMVA::Types::kLikelihood, "Likelihood",
                        "H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50" );


   if (false)
   {
       TString layoutString ("Layout=TANH|100,LINEAR");

       TString training0 ("LearningRate=1e-1,Momentum=0.0,Repetitions=1,ConvergenceSteps=300,BatchSize=20,TestRepetitions=15,WeightDecay=0.001,Regularization=NONE,DropConfig=0.0+0.5+0.5+0.5,DropRepetitions=1,Multithreading=True");
       TString training1 ("LearningRate=1e-2,Momentum=0.5,Repetitions=1,ConvergenceSteps=300,BatchSize=30,TestRepetitions=7,WeightDecay=0.001,Regularization=L2,Multithreading=True,DropConfig=0.0+0.1+0.1+0.1,DropRepetitions=1");
       TString training2 ("LearningRate=1e-2,Momentum=0.3,Repetitions=1,ConvergenceSteps=300,BatchSize=40,TestRepetitions=7,WeightDecay=0.0001,Regularization=L2,Multithreading=True");
       TString training3 ("LearningRate=1e-3,Momentum=0.1,Repetitions=1,ConvergenceSteps=200,BatchSize=70,TestRepetitions=7,WeightDecay=0.0001,Regularization=NONE,Multithreading=True");

       TString trainingStrategyString ("TrainingStrategy=");
       trainingStrategyString += training0 + "|" + training1 + "|" + training2 + "|" + training3;
      
       TString nnOptions ("!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=G:WeightInitialization=XAVIERUNIFORM");
       nnOptions.Append (":"); nnOptions.Append (layoutString);
       nnOptions.Append (":"); nnOptions.Append (trainingStrategyString);

       factory->BookMethod( TMVA::Types::kNN, "NN_gauss", nnOptions ); // NN
   }

   {
       TString layoutString ("Layout=TANH|100,LINEAR");

       TString training0 ("LearningRate=1e-1,Momentum=0.0,Repetitions=1,ConvergenceSteps=300,BatchSize=20,TestRepetitions=15,WeightDecay=0.001,Regularization=NONE,DropConfig=0.0+0.5+0.5+0.5,DropRepetitions=1,Multithreading=True");
       TString training1 ("LearningRate=1e-2,Momentum=0.5,Repetitions=1,ConvergenceSteps=300,BatchSize=30,TestRepetitions=7,WeightDecay=0.001,Regularization=L2,Multithreading=True,DropConfig=0.0+0.1+0.1+0.1,DropRepetitions=1");
       TString training2 ("LearningRate=1e-2,Momentum=0.3,Repetitions=1,ConvergenceSteps=300,BatchSize=40,TestRepetitions=7,WeightDecay=0.0001,Regularization=L2,Multithreading=True");
       TString training3 ("LearningRate=1e-3,Momentum=0.1,Repetitions=1,ConvergenceSteps=200,BatchSize=70,TestRepetitions=7,WeightDecay=0.0001,Regularization=NONE,Multithreading=True");

       TString trainingStrategyString ("TrainingStrategy=");
       trainingStrategyString += training0 + "|" + training1 + "|" + training2 + "|" + training3;

      
//       TString nnOptions ("!H:V:VarTransform=Normalize:ErrorStrategy=CROSSENTROPY");
       TString nnOptions ("!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM");
//       TString nnOptions ("!H:V:VarTransform=Normalize:ErrorStrategy=CHECKGRADIENTS");
       nnOptions.Append (":"); nnOptions.Append (layoutString);
       nnOptions.Append (":"); nnOptions.Append (trainingStrategyString);

       factory->BookMethod( TMVA::Types::kNN, "NN_normalized", nnOptions ); // NN
   }


   {
       TString layoutString ("Layout=TANH|100,TANH|50,LINEAR");

       TString training0 ("LearningRate=1e-1,Momentum=0.0,Repetitions=1,ConvergenceSteps=300,BatchSize=20,TestRepetitions=15,WeightDecay=0.001,Regularization=NONE,DropConfig=0.0+0.5+0.5+0.5,DropRepetitions=1,Multithreading=True");
       TString training1 ("LearningRate=1e-2,Momentum=0.5,Repetitions=1,ConvergenceSteps=300,BatchSize=30,TestRepetitions=7,WeightDecay=0.001,Regularization=L2,Multithreading=True,DropConfig=0.0+0.1+0.1+0.1,DropRepetitions=1");
       TString training2 ("LearningRate=1e-2,Momentum=0.3,Repetitions=1,ConvergenceSteps=300,BatchSize=40,TestRepetitions=7,WeightDecay=0.0001,Regularization=L2,Multithreading=True");
       TString training3 ("LearningRate=1e-3,Momentum=0.1,Repetitions=1,ConvergenceSteps=200,BatchSize=70,TestRepetitions=7,WeightDecay=0.0001,Regularization=NONE,Multithreading=True");

       TString trainingStrategyString ("TrainingStrategy=");
       trainingStrategyString += training0 + "|" + training1 + "|" + training2 + "|" + training3;

      
//       TString nnOptions ("!H:V:VarTransform=Normalize:ErrorStrategy=CROSSENTROPY");
       TString nnOptions ("!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM");
//       TString nnOptions ("!H:V:VarTransform=Normalize:ErrorStrategy=CHECKGRADIENTS");
       nnOptions.Append (":"); nnOptions.Append (layoutString);
       nnOptions.Append (":"); nnOptions.Append (trainingStrategyString);

       factory->BookMethod( TMVA::Types::kNN, "NN_normalized_2", nnOptions ); // NN
   }
   
   
   
   factory->TrainAllMethods();
   factory->TestAllMethods();
   factory->EvaluateAllMethods();

   //input->Close();
   outputFile->Close();

   delete factory;
}


void TMVAPredict()
{
  TMVA::Tools::Instance();

  std::cout << "==> Start TMVAPredict" << std::endl;
  TMVA::Reader *reader = new TMVA::Reader( "!Color:!Silent" );  
  std::vector<std::string> variableNames = {
      "LifeTime",
      "FlightDistance",
      "FlightDistanceError",
      "pt",
      "IP",
      "dira",
      "DOCAone",      
      "DOCAtwo",
      "DOCAthree",
      "IP_p0p2",
      "IP_p1p2",
      "isolationa",
      "isolationb",
      "isolationc",
      "isolationd",
      "isolatione",
      "isolationf",
      "iso",
      "CDF1",
      "CDF2",
      "CDF3",
      "ISO_SumBDT",
      "p0_IsoBDT",
      "p1_IsoBDT",
      "p2_IsoBDT",
      "p0_track_Chi2Dof",
      "p1_track_Chi2Dof",
      "p2_track_Chi2Dof",
      "p0_pt",
      "p0_p",
      "p0_eta",
      "p0_IP",
      "p0_IPSig",
      "p1_pt",
      "p1_p",
      "p1_eta",
      "p1_IP",
      "p1_IPSig",
      "p2_pt",
      "p2_p",
      "p2_eta",
      "p2_IP",
      "p2_IPSig"};//,
//      "SPDhits"};


//  Float_t variables[3];
  std::vector<Float_t> variables (variableNames.size ());
  auto itVar = begin (variables);
  for (auto varName : variableNames)
  {
      Float_t* pVar = &(*itVar);
      reader->AddVariable(varName.c_str(), pVar);
      (*itVar) = 0.0;
      ++itVar;
  }

  TString dir    = "weights/";
  TString prefix = "TMVAClassification";
//  TString method_name = "NN_normalized";
  TString method_name = "GBDT";
  TString weightfile = dir + prefix + TString("_") + method_name + TString(".weights.xml");
  reader->BookMVA( method_name, weightfile ); 

  

  
  std::vector<std::string> inputNames = {"test","check_correlation","check_agreement"};
  std::map<std::string,std::vector<std::string>> varsForInput;
  varsForInput["test"].emplace_back ("id");
  varsForInput["test"].emplace_back ("prediction");

  varsForInput["check_agreement"].emplace_back ("signal");
  varsForInput["check_agreement"].emplace_back ("weight");
  varsForInput["check_agreement"].emplace_back ("prediction");

  varsForInput["check_correlation"].emplace_back ("mass");
  varsForInput["check_correlation"].emplace_back ("prediction");
  
  for (auto inputName : inputNames)
  {
      std::stringstream outfilename;
      outfilename << inputName << "_prediction.csv";

      std::stringstream infilename;
      infilename << "../tau_data/" << inputName << ".root";
          
      std::ofstream outfile (outfilename.str ());
      bool isFirst = true;
      for (auto inputName : varsForInput[inputName])
      {
          if (!isFirst)
          {
              outfile << ",";
          }
          else
              isFirst = false;
          outfile << inputName;
      }
      outfile << "\n";


      TFile *input(0);
      std::cout << "infilename = " << infilename.str ().c_str () << std::endl;
      input = TFile::Open (infilename.str ().c_str ());
      TTree* tree = (TTree*)input->Get("data");
  
      Int_t ids;
      Float_t prediction;
      Float_t weight;
      Float_t mass;
      Float_t signal;

      // id field if needed
      if (std::find (varsForInput[inputName].begin (), varsForInput[inputName].end (), "id") != varsForInput[inputName].end ())
          tree->SetBranchAddress("id", &ids);

      // signal field if needed
      if (std::find (varsForInput[inputName].begin (), varsForInput[inputName].end (), "signal") != varsForInput[inputName].end ())
          tree->SetBranchAddress("signal", &signal);

      // mass field if needed
      if (std::find (varsForInput[inputName].begin (), varsForInput[inputName].end (), "mass") != varsForInput[inputName].end ())
          tree->SetBranchAddress("mass", &mass);

      // weight field if needed
      if (std::find (varsForInput[inputName].begin (), varsForInput[inputName].end (), "weight") != varsForInput[inputName].end ())
          tree->SetBranchAddress("weight", &weight);

      
      // variables for prediction
      itVar = begin (variables);
      for (auto inputName : variableNames)
      {
          Float_t* pVar = &(*itVar);
          tree->SetBranchAddress(inputName.c_str(), pVar);
          ++itVar;
      }  
 
      for (Long64_t ievt=0; ievt < tree->GetEntries(); ievt++)
      {
          tree->GetEntry(ievt);
          // predict
          prediction = reader->EvaluateMVA (method_name);

          if (std::find (varsForInput[inputName].begin (), varsForInput[inputName].end (), "id") != varsForInput[inputName].end ())
              outfile << ids << ",";

          if (std::find (varsForInput[inputName].begin (), varsForInput[inputName].end (), "signal") != varsForInput[inputName].end ())
              outfile << signal << ",";

          if (std::find (varsForInput[inputName].begin (), varsForInput[inputName].end (), "mass") != varsForInput[inputName].end ())
              outfile << mass << ",";

          if (std::find (varsForInput[inputName].begin (), varsForInput[inputName].end (), "weight") != varsForInput[inputName].end ())
              outfile << weight << ",";

          if (std::find (varsForInput[inputName].begin (), varsForInput[inputName].end (), "prediction") != varsForInput[inputName].end ())
              outfile << (prediction + 1.) / 2.;

          
          
          outfile << "\n";
      }

      outfile.close();
      input->Close();
  }
  delete reader;
}


int competition()
{
  TMVAClassification();
  cout << "Classifier have been trained\n";
//  TMVAPredict();
//  cout << "Submission is ready: baseline_c.csv; send it\n";
  return 0;
}
